<!DOCTYPE html>
<html lang="en-us"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Recently, I became interested in cryptographic hash functions. To my surprise, I couldn&#39;t find any good, comprehensive resources online explaining exactly how they work, and so I had to look through dozens of articles, textbooks, and papers to get just a fraction of the level of understanding I wanted. I figured I&#39;d write this post to save others interested in hash functions the trouble of doing what I did.
In terms of prerequisites, besides basic programming knowledge, you should know what bit-wise operators are. ">

    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=Roboto:ital,wght@0,400;0,500;1,400;1,500&display=swap" rel="stylesheet">

    

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
    
    <title>Adar Kahiri | Hash Functions For The Technical Layman</title>
</head><body><h1 style="margin-bottom: 10px;">Adar Kahiri</h1>
    
    <nav>
        
            <a class="nav-item" href="/"><b>About</b></a>
        
            <a class="nav-item" href="/blog/"><b>Blog</b></a>
        
    </nav><main id="content">
    
        <h2 class="blog-title">Hash Functions For The Technical Layman</h2>
<p class="date">December 16, 2020</p>


    
    <p>Recently, I became interested in cryptographic hash functions. To my surprise, I couldn't find any good, comprehensive resources online explaining exactly how they work, and so I had to look through dozens of articles, textbooks, and papers to get just a fraction of the level of understanding I wanted. I figured I'd write this post to save others interested in hash functions the trouble of doing what I did.</p>

<p>In terms of prerequisites, besides basic programming knowledge, you should know what <a target="_blank" href="https://www.programiz.com/c-programming/bitwise-operators">bit-wise operators</a> are.</p>

<h3 id="contents">Contents</h3>

<ol>
<li>What is a hash function?</li>
<li>Block ciphers</li>
<li>Compression functions</li>
<li>The Merkle-Damgård construction</li>
<li>Putting it all together</li>
<li>Examples</li>
<li>Further reading</li>
</ol>

<p><br></p>

<h2 id="what-is-a-hash-function">What is a hash function?</h2>

<p>At its very core, a hash function is simply a function that takes some string of bits and outputs another string of bits of fixed size,</p>

<p><span  class="math">\[ \text{hash}(0111010100011011010100) = 000110101001 \]</span></p>

<p><span  class="math">\[ \text{hash}(00100100) = 100010111111 \]</span></p>

<p>where the output is called the <strong>hash</strong> of the input.</p>

<p>For a hash-function to be useful (from the perspective of cryptography), it must, among other things, have the property of <em>collision-resistance</em>. A collision occurs when two
distinct inputs have the same output. So in order for a hash function to be collision-resistant, it should be really difficult to find two inputs that have the exact same hash. Further still, there are two properties that are necessary for having collision-resistance: <strong>irreversibility</strong> and <strong>randomness</strong>.</p>

<p>Irreversibility is simply the property that, given some hash, you have no better method for finding an input that gives that hash than simply guessing and checking. Randomness is the property that
there is no relationship between the input and output. If a hash function is truly random, changing so much as one bit of the input string should result in a completely different output string. In reality, a determinstic algorithm cannot, by definition, yield completely random output, but we can get close. (to see just how close we can get, I encourage you to play around <a target="_blank" href="https://geraintluff.github.io/sha256/">this demo</a> of SHA-256, a commonly-used hash function.)</p>

<p>Okay, so we know more or less what a hash function is, but what is it actually used for? The short answer is, a lot of things. Because (useful) hash functions are collision-resistant, they are used pretty much any time an efficient method is needed for determining if any changes have been made to some data.</p>

<p>For example, the popular version-control system Git uses hashing to efficiently check if any changes have been made to a repository, and in what file or folder those changes were made. Along with each file and folder, git stores a hash which is generated using the contents inside as input. If my respository structure is</p>

<p>dir1</p>

<ul>
<li>dir11

<ul>
<li>dir12

<ul>
<li>file1</li>
</ul></li>
</ul></li>
<li>dir2

<ul>
<li>bunch of files and folders</li>
</ul></li>
<li>dir3

<ul>
<li>bunch of files and folders</li>
</ul></li>
</ul>

<p>and I make changes to file1, then the hash of file1 should now be different. Since the hash of dir12 depends on the hash of file1, the hash of dir12 should now be different as well. As you can see, these changes propagate all the way up to dir1, whose hash should now be different as well. Since no changes have been made to any of the files in dir2 and dir3, those files' hashes will remain the same, meaning the hashes of dir2, dir3 will remain the same as well. When I want to push my changes to a remote repository (on Github, for example), instead of sending my entire repository (which would take up a lot of bandwidth) I can simply send the hashes of all of my files and folders, compare it to the hashes of the files and folders in the remote repository, and then only send the files and/or folders (in this case just file1) for which the hashes are different. Needless to say, this is far more efficient. [1]</p>

<p>Hash functions are also used to prove the authenticity of messages in insecure communication channels and to prevent bad-actors from tampering with ledgers in cryptocurrencies like Bitcoin, among other things. All of these applications warrant their own posts, but it should hopefully be more clear why we care about hash functions having certain properties.</p>

<p>So how do hash functions <em>actually</em> work? It turns out the path to fully understanding this is a bit long, but not necessarily difficult. The TLDR is that a common way to construct hash functions is with algorithms called compression functions, which are commonly built with yet more algorithms called block ciphers [2]. So in order to understand hash functions (or at least some of them), we must understand compression functions and block ciphers.</p>

<p><br></p>

<h2 id="block-ciphers">Block ciphers</h2>

<p>A block cipher is a symmetric cipher that operates on groups of bits of fixed-length called &quot;blocks&quot;. The word 'symmetric' just means that the same key that is used to encrypt data is also used to decrypt it. The simplest example of something that's <em>technically</em> a block cipher (albeit a bad one) is the XOR cipher: you have a message <span  class="math">\(m\)</span> of length <span  class="math">\(n\)</span> you'd like to encrypt, so you generate a key <span  class="math">\(k\)</span> of the same length. Your ciphertext <span  class="math">\(c\)</span> is then <span  class="math">\(m \oplus k\)</span>. To decrypt <span  class="math">\(c\)</span>, you XOR it with <span  class="math">\(k\)</span>, getting back <span  class="math">\(m\)</span>.</p>

<p>For example, if <span  class="math">\(m = 01010101\)</span> and <span  class="math">\(k = 11101100\)</span>, then</p>

<p><span  class="math">\[ c = m \oplus k = 10111001 \]</span></p>

<p>and</p>

<p><span  class="math">\[m = c \oplus k = 01010101 \]</span></p>

<p>This property of getting back the original message when applying the key twice directly follows from XOR being an <a target="_blank" href="https://en.wikipedia.org/wiki/Associative_property">associative</a> operation. For if <span  class="math">\(A\)</span> and <span  class="math">\(B\)</span> are bits, then <span  class="math">\(A \oplus B \oplus B = A \oplus (B \oplus B) = A \oplus 0 = A\)</span>. I won't prove the associativity of XOR here, but I encourage you to play around with the operation to get a sense for why it's associative (and commutative).</p>

<p>As it turns out, the XOR cipher isn't a good 'block' cipher on its own for a number of reasons [3], and there are actually several requirements imposed on block ciphers that are intended for use in hash functions:</p>

<ul>
<li>The block-width (length of the input and output, not including the key) must be the same as the desired length of the hash function's output</li>
<li>They must be immune to <strong>related-key attacks</strong>, which are defined in Wikipedia as a &quot;form of cryptanalysis where the attacker can observe the operation of a cipher under several different keys whose values are initially unknown, but where some mathematical relationship connecting the keys is known to the attacker&quot;.</li>
</ul>

<p><br></p>

<h2 id="compression-functions">Compression functions</h2>

<p>A one-way compression function is a function that takes two bit strings of fixed-length as input (or equivalently, one bitstring of fixed-length), and outputs another fixed-length bit-string. In order for a compression function to be useful for the purposes of cryptography, it must be collision-resistant, with collision-resistance defined in the same way as for hash functions.</p>

<p>How does one create a satisfactory compression function? One method is using block ciphers, by way of the <strong>Davies-Meyer construction</strong>. The formal definition of this construction is as follows:</p>

<p><em>Let <span  class="math">\(E\)</span> be a block cipher. Let <span  class="math">\(M\)</span> be the message to be compressed, and let <span  class="math">\(m_i\)</span> represented one of the <span  class="math">\(m_1, \ldots, m_n\)</span> blocks of the message. Begin with some pre-specified initial hash <span  class="math">\(H_0\)</span>.</em></p>

<p><em>Then</em></p>

<p><span  class="math">\[H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1}\]</span></p>

<p><em>where <span  class="math">\(m_i\)</span> is the key given to the block cipher, and <span  class="math">\(H_{i-1}\)</span> is the block to be encrypted. Repeating this process iteratively, <span  class="math">\(H_n\)</span> is the final output of the compression function.</em></p>

<p>Let's think through why it was designed this way. Firstly, we know that in order for our compression function to be useful, it must be random—or close to it. Another way of thinking about randomness that was mentioned earlier is that each individual bit of input should affect each individual bit of the output. Encrypting previous hashes with the current message ensures that exactly this happens. <span  class="math">\(H_1\)</span> is dependent on the bits in <span  class="math">\(m_1\)</span>, <span  class="math">\(H_2\)</span> is dependent on the bits in <span  class="math">\(m_1, m_2\)</span>, and so on.</p>

<p>The other interesting feature of the construction is the fact that each ciphertext (encrypted form of <span  class="math">\(H_{i-1}\)</span>) is XORed with <span  class="math">\(H_{i-1}\)</span>. This is done because finding collisions is trivial otherwise. Suppose our construction was just</p>

<p><span  class="math">\[H_i = E_{m_i}(H_{i-1}).\]</span></p>

<p>We wish to find some <span  class="math">\(m_i^{'}\)</span> and <span  class="math">\(H^{'}_{i-1}\)</span> such that <span  class="math">\(E_{m_i}(H_{i-1}) = E_{m^{'}_i}(H^{'}_{i-1})\)</span>. This would constitute a collision because if the message block <span  class="math">\(m^{'}_i\)</span> is different from <span  class="math">\(m_i\)</span>, then the entire message <span  class="math">\(M'\)</span> is different from <span  class="math">\(M\)</span>.</p>

<p>So, how do we find <span  class="math">\(m_i^{'}\)</span> and <span  class="math">\(H^{'}_{i-1}\)</span>? Choose an arbitrary <span  class="math">\(m_i^{'}\)</span>, and let</p>

<p><span  class="math">\[H^{'}_{i-1} = E^{-1}_{m_i^{'}}(H_{i-1})\]</span></p>

<p>where <span  class="math">\(E^{-1}\)</span> is the decryption function of our chosen block cipher. Then</p>

<p><span  class="math">\[E_{m_i^{'}}(H^{'}_{i-1}) = E_{m_i^{'}}(E^{-1}_{m_i^{'}}(H_{i-1})) = H_{i-1}.\]</span></p>

<p>This trick can't be used in the actual construction because of the XOR. It should also be noted that XOR isn't the only operation that can be used to prevent this.</p>

<p>If <span  class="math">\(E\)</span> is an <a target="_blank" href="https://crypto.stackexchange.com/questions/10347/what-is-the-ideal-cipher-model">ideal cipher</a>, then the Davies-Meyer construction is <strong>provably secure</strong>, meaning that an attacker has no better method for finding collisions than just guessing (security can be defined more formally than this, but this notion should suffice for the purposes of this article). Being 'ideal', the ideal cipher doesn't actually exist, but there are block ciphers which have been shown to be 'secure enough' for cryptographers to feel comfortable using them in constructions like Davies-Meyer.</p>

<p><br></p>

<h2 id="the-merkledamgård-construction">The Merkle-Damgård construction</h2>

<p><br></p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p><br></p>

<h2 id="examples">Examples</h2>

<p><br></p>

<h2 id="referencesfurther-reading">References/Further reading</h2>

<p>Many thanks to <a href="https://crypto.stackexchange.com/users/555/fgrieu">fgrieu</a> on the crypto StackExchange for answering my question regarding block ciphers. You can find my question and their answer <a href="https://crypto.stackexchange.com/questions/86988/which-block-ciphers-are-considered-staples-for-constructing-hash-functions">here</a>.</p>

<p><br></p>

<h3 id="footnotes">Footnotes</h3>

<p>[1] This is an oversimplified explanation of Git, but if you're interested in learning more about data-structures like this, look into 'Merkle trees'.</p>

<p>[2] It should be emphasized that this isn't the only way to construct hash/compression functions. For example, <a target="_blank" href="http://www.arpnjournals.org/jeas/research_papers/rp_2016/jeas_1116_5354.pdf">this paper</a> proposes a more efficient method for constructing compression functions using algebraic objects called 'quasigroups'. For the purposes of this post, however, the goal is just to explain the most common ways in which hash functions are built.</p>

<p>[3] Most notably, the XOR cipher is vulnerable to <a target="_blank" href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a>, but there are other reasons.</p>


        </main></body>
</html>
